------- AFTER CONTROLLED COMPONENTS


---

# Using `ref` to reference native elements ‚è©

---

# The problem

You want to do something with the actual DOM element

<ul style={{ fontSize: "1.5em" }}>
  <Appear>
    <li>
      Managing focus, text selection, or media playback
    </li>
    <li>Integrating with third-party DOM libraries</li>
  </Appear>
</ul>

---

<CodeSurfer
  title="How do we do that within React?"
  code={require("!raw-loader!./examples/ref-base.js")}
  lang="jsx"
  showNumbers={true}
  theme={nightOwl}
  steps={[{}, { range: [6, 13] }, { range: [2, 4] }]}
/>

---

# Do it like we always do?

<ul style={{ fontSize: "1.5em" }}>
  <Appear>
    <li>
      <code>document.getElementById('id');</code>
    </li>
    <li>
      <code>document.querySelector('.theClass');</code>
    </li>
    <li>It's not the React way</li>
    <li>
      React works on the DOM, so you don't have to (and
      shouldn't)
    </li>
    <li>
      We don't know what happens in the DOM, so it's
      dangerous to interact with it directly
    </li>
  </Appear>
</ul>

---

# `ref` to the rescue!

<ul style={{ fontSize: "1.5em" }}>
  <Appear>
    <li>
      Reference the native element from a class variable
    </li>
    <li>
      The class variable is now a "DOM element" given to you
      by React
    </li>
    <li>Now we can do anything with it, within React!</li>
  </Appear>
</ul>

---

<CodeSurfer
  title="Adding a ref"
  code={require("!raw-loader!./examples/ref-final.js")}
  lang="jsx"
  showNumbers={true}
  theme={nightOwl}
  steps={[{ lines: [2] }, { lines: [11] }, { lines: [5] }]}
/>

--------------------- BEFORE ASSIGNMENTS PART 2

--------------------- AFTER "IS IT WORKING" ROUTING


## What if we want to read from the location within any component? ü§î

<ul style={{ fontSize: "1.5em" }}>
  <Appear>
    <li>Show information based on current location</li>
    <li>Header showing current page</li>
    <li>Log location to backend</li>
  </Appear>
</ul>

---

# `withRouter()` HOC to the rescue üí™

<ul style={{ fontSize: "1.5em" }}>
  <Appear>
    <li>
      Wrap any component in <Code code="withRouter()" />
    </li>
    <li>
      Get <Code code="location" /> and{" "}
      <Code code="history" /> as props
    </li>
  </Appear>
</ul>

---

<CodeSurfer
  title="Using the withRouter() HOC"
  code={require("!raw-loader!./examples/with-router.js")}
  lang="jsx"
  showNumbers={true}
  theme={nightOwl}
  steps={[
    {
      range: [1, 4],
      notes: "Simple routing aware Header"
    },
    {
      range: [1, 6],
      notes: "Wrap in withRouter()"
    }
  ]}
/>

---


--------------------- BEFORE "WHEN TO ROUTE"


--------------------- AFTER "WHEN TO USE RENDER PROPS VS HOCS"


---

title: Render props are more explicit about behavior

demo

---

title: HOCs tend to "hide" the enhancement = harder to understand Component

demo

---

Render props are a pain to combine

demo render prop

---

demo combining hoc

---

render props and lifecycles

demo


------------------ BEFORE RENDER PROPS RULE OF THUMB

------------------ AFTER ORDERPIZZABUTTON USAGE

<CodeSurferNoZoom
  title="Building a withNetwork HOC"
  code={require("!raw-loader!./examples/with-network-hoc.js")}
  lang="jsx"
  showNumbers={true}
  theme={nightOwl}
  steps={[
    { range: [1, 24] },
    { lines: [1] },
    { lines: [2] },
    { lines: [3] },
    { range: [5, 8] },
    { range: [5, 13] },
    { range: [15, 22] },
    { lines: [19] },
    { range: [1, 24] }
  ]}
/>

---------------- BEFORE HOC SUM UP


Let us see how the Network Render prop component is implemented

---

<CodeSurferNoZoom
  code={require("!raw-loader!./examples/network-render-prop.js")}
  lang="jsx"
  showNumbers={true}
  theme={nightOwl}
  steps={[
    {},
    {
      lines: [1]
    },
    {
      range: [2, 12]
    },
    {
      range: [14, 16]
    },
    { notes: "Done! ü•≥" }
  ]}
/>

---

--------------------- BEFORE WHEN TO USE RENDER PROP